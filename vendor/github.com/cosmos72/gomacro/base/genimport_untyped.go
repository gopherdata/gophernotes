/*
 * gomacro - A Go interpreter with Lisp-like macros
 *
 * Copyright (C) 2017 Massimiliano Ghilardi
 *
 *     This program is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU Lesser General Public License as published
 *     by the Free Software Foundation, either version 3 of the License, or
 *     (at your option) any later version.
 *
 *     This program is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU Lesser General Public License for more details.
 *
 *     You should have received a copy of the GNU Lesser General Public License
 *     along with this program.  If not, see <https://www.gnu.org/licenses/lgpl>.
 *
 *
 * genimport_untyped.go
 *
 *  Created on May 27, 2017
 *      Author Massimiliano Ghilardi
 */

package base

import (
	"fmt"
	"go/constant"
	"go/token"
	"go/types"
	"strings"
)

func MarshalUntyped(kind types.BasicKind, val constant.Value) string {
	// untyped constants have arbitrary precision... they may overflow integers
	switch kind {
	case types.UntypedBool:
		if constant.BoolVal(val) {
			return "bool:true"
		} else {
			return "bool:false"
		}
	case types.UntypedInt:
		return fmt.Sprintf("int:%s", val.ExactString())
	case types.UntypedRune:
		return fmt.Sprintf("rune:%s", val.ExactString())
	case types.UntypedFloat:
		return fmt.Sprintf("float:%s", val.ExactString())
	case types.UntypedComplex:
		return fmt.Sprintf("complex:%s:%s", constant.Real(val).ExactString(), constant.Imag(val).ExactString())
	case types.UntypedString:
		return fmt.Sprintf("string:%s", constant.StringVal(val))
	case types.UntypedNil:
		return "nil"
	default:
		return ""
	}
}

func UnmarshalUntyped(marshalled string) (types.BasicKind, constant.Value) {
	var skind, str string
	if sep := strings.IndexByte(marshalled, ':'); sep >= 0 {
		skind = marshalled[:sep]
		str = marshalled[sep+1:]
	} else {
		skind = marshalled
	}

	var kind types.BasicKind
	var val constant.Value
	switch skind {
	case "bool":
		kind = types.UntypedBool
		if str == "true" {
			val = constant.MakeBool(true)
		} else {
			val = constant.MakeBool(false)
		}
	case "int":
		kind = types.UntypedInt
		val = constant.MakeFromLiteral(str, token.INT, 0)
	case "rune":
		kind = types.UntypedRune
		val = constant.MakeFromLiteral(str, token.INT, 0)
	case "float":
		kind = types.UntypedFloat
		val = unmarshalUntypedFloat(str)
	case "complex":
		kind = types.UntypedComplex
		if sep := strings.IndexByte(str, ':'); sep >= 0 {
			re := unmarshalUntypedFloat(str[:sep])
			im := unmarshalUntypedFloat(str[sep+1:])
			val = constant.BinaryOp(constant.ToComplex(re), token.ADD, constant.MakeImag(im))
		} else {
			val = constant.ToComplex(unmarshalUntypedFloat(str))
		}
	case "string":
		kind = types.UntypedString
		val = constant.MakeString(str)
	case "nil":
		kind = types.UntypedNil
	default:
		kind = types.Invalid
	}
	return kind, val
}

// generalization of constant.MakeFromLiteral, accepts the fractions generated by
// constant.Value.ExactString() for floating-point values
func unmarshalUntypedFloat(str string) constant.Value {
	if sep := strings.IndexByte(str, '/'); sep >= 0 {
		x := constant.MakeFromLiteral(str[:sep], token.FLOAT, 0)
		y := constant.MakeFromLiteral(str[sep+1:], token.FLOAT, 0)
		return constant.BinaryOp(x, token.QUO, y)
	}
	return constant.MakeFromLiteral(str, token.FLOAT, 0)
}
