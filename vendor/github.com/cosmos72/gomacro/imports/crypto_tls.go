// this file was generated by gomacro command: import _b "crypto/tls"
// DO NOT EDIT! Any change will be lost when the file is re-generated

package imports

import (
	. "reflect"
	"crypto/tls"
)

// reflection: allow interpreted code to import "crypto/tls"
func init() {
	Packages["crypto/tls"] = Package{
	Binds: map[string]Value{
		"Client":	ValueOf(tls.Client),
		"CurveP256":	ValueOf(tls.CurveP256),
		"CurveP384":	ValueOf(tls.CurveP384),
		"CurveP521":	ValueOf(tls.CurveP521),
		"Dial":	ValueOf(tls.Dial),
		"DialWithDialer":	ValueOf(tls.DialWithDialer),
		"ECDSAWithP256AndSHA256":	ValueOf(tls.ECDSAWithP256AndSHA256),
		"ECDSAWithP384AndSHA384":	ValueOf(tls.ECDSAWithP384AndSHA384),
		"ECDSAWithP521AndSHA512":	ValueOf(tls.ECDSAWithP521AndSHA512),
		"Listen":	ValueOf(tls.Listen),
		"LoadX509KeyPair":	ValueOf(tls.LoadX509KeyPair),
		"NewLRUClientSessionCache":	ValueOf(tls.NewLRUClientSessionCache),
		"NewListener":	ValueOf(tls.NewListener),
		"NoClientCert":	ValueOf(tls.NoClientCert),
		"PKCS1WithSHA1":	ValueOf(tls.PKCS1WithSHA1),
		"PKCS1WithSHA256":	ValueOf(tls.PKCS1WithSHA256),
		"PKCS1WithSHA384":	ValueOf(tls.PKCS1WithSHA384),
		"PKCS1WithSHA512":	ValueOf(tls.PKCS1WithSHA512),
		"PSSWithSHA256":	ValueOf(tls.PSSWithSHA256),
		"PSSWithSHA384":	ValueOf(tls.PSSWithSHA384),
		"PSSWithSHA512":	ValueOf(tls.PSSWithSHA512),
		"RenegotiateFreelyAsClient":	ValueOf(tls.RenegotiateFreelyAsClient),
		"RenegotiateNever":	ValueOf(tls.RenegotiateNever),
		"RenegotiateOnceAsClient":	ValueOf(tls.RenegotiateOnceAsClient),
		"RequestClientCert":	ValueOf(tls.RequestClientCert),
		"RequireAndVerifyClientCert":	ValueOf(tls.RequireAndVerifyClientCert),
		"RequireAnyClientCert":	ValueOf(tls.RequireAnyClientCert),
		"Server":	ValueOf(tls.Server),
		"TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA":	ValueOf(tls.TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA),
		"TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256":	ValueOf(tls.TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256),
		"TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256":	ValueOf(tls.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256),
		"TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA":	ValueOf(tls.TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA),
		"TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384":	ValueOf(tls.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384),
		"TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305":	ValueOf(tls.TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305),
		"TLS_ECDHE_ECDSA_WITH_RC4_128_SHA":	ValueOf(tls.TLS_ECDHE_ECDSA_WITH_RC4_128_SHA),
		"TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA":	ValueOf(tls.TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA),
		"TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA":	ValueOf(tls.TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA),
		"TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256":	ValueOf(tls.TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256),
		"TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256":	ValueOf(tls.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256),
		"TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA":	ValueOf(tls.TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA),
		"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384":	ValueOf(tls.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384),
		"TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305":	ValueOf(tls.TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305),
		"TLS_ECDHE_RSA_WITH_RC4_128_SHA":	ValueOf(tls.TLS_ECDHE_RSA_WITH_RC4_128_SHA),
		"TLS_FALLBACK_SCSV":	ValueOf(tls.TLS_FALLBACK_SCSV),
		"TLS_RSA_WITH_3DES_EDE_CBC_SHA":	ValueOf(tls.TLS_RSA_WITH_3DES_EDE_CBC_SHA),
		"TLS_RSA_WITH_AES_128_CBC_SHA":	ValueOf(tls.TLS_RSA_WITH_AES_128_CBC_SHA),
		"TLS_RSA_WITH_AES_128_CBC_SHA256":	ValueOf(tls.TLS_RSA_WITH_AES_128_CBC_SHA256),
		"TLS_RSA_WITH_AES_128_GCM_SHA256":	ValueOf(tls.TLS_RSA_WITH_AES_128_GCM_SHA256),
		"TLS_RSA_WITH_AES_256_CBC_SHA":	ValueOf(tls.TLS_RSA_WITH_AES_256_CBC_SHA),
		"TLS_RSA_WITH_AES_256_GCM_SHA384":	ValueOf(tls.TLS_RSA_WITH_AES_256_GCM_SHA384),
		"TLS_RSA_WITH_RC4_128_SHA":	ValueOf(tls.TLS_RSA_WITH_RC4_128_SHA),
		"VerifyClientCertIfGiven":	ValueOf(tls.VerifyClientCertIfGiven),
		"VersionSSL30":	ValueOf(tls.VersionSSL30),
		"VersionTLS10":	ValueOf(tls.VersionTLS10),
		"VersionTLS11":	ValueOf(tls.VersionTLS11),
		"VersionTLS12":	ValueOf(tls.VersionTLS12),
		"X25519":	ValueOf(tls.X25519),
		"X509KeyPair":	ValueOf(tls.X509KeyPair),
	}, Types: map[string]Type{
		"Certificate":	TypeOf((*tls.Certificate)(nil)).Elem(),
		"CertificateRequestInfo":	TypeOf((*tls.CertificateRequestInfo)(nil)).Elem(),
		"ClientAuthType":	TypeOf((*tls.ClientAuthType)(nil)).Elem(),
		"ClientHelloInfo":	TypeOf((*tls.ClientHelloInfo)(nil)).Elem(),
		"ClientSessionCache":	TypeOf((*tls.ClientSessionCache)(nil)).Elem(),
		"ClientSessionState":	TypeOf((*tls.ClientSessionState)(nil)).Elem(),
		"Config":	TypeOf((*tls.Config)(nil)).Elem(),
		"Conn":	TypeOf((*tls.Conn)(nil)).Elem(),
		"ConnectionState":	TypeOf((*tls.ConnectionState)(nil)).Elem(),
		"CurveID":	TypeOf((*tls.CurveID)(nil)).Elem(),
		"RecordHeaderError":	TypeOf((*tls.RecordHeaderError)(nil)).Elem(),
		"RenegotiationSupport":	TypeOf((*tls.RenegotiationSupport)(nil)).Elem(),
		"SignatureScheme":	TypeOf((*tls.SignatureScheme)(nil)).Elem(),
	}, Proxies: map[string]Type{
		"ClientSessionCache":	TypeOf((*P_crypto_tls_ClientSessionCache)(nil)).Elem(),
	}, Untypeds: map[string]string{
		"VersionSSL30":	"int:768",
		"VersionTLS10":	"int:769",
		"VersionTLS11":	"int:770",
		"VersionTLS12":	"int:771",
	}, 
	}
}

// --------------- proxy for crypto/tls.ClientSessionCache ---------------
type P_crypto_tls_ClientSessionCache struct {
	Object	interface{}
	Get_	func(_proxy_obj_ interface{}, sessionKey string) (session *tls.ClientSessionState, ok bool)
	Put_	func(_proxy_obj_ interface{}, sessionKey string, cs *tls.ClientSessionState) 
}
func (P *P_crypto_tls_ClientSessionCache) Get(sessionKey string) (session *tls.ClientSessionState, ok bool) {
	return P.Get_(P.Object, sessionKey)
}
func (P *P_crypto_tls_ClientSessionCache) Put(sessionKey string, cs *tls.ClientSessionState)  {
	P.Put_(P.Object, sessionKey, cs)
}
