// this file was generated by gomacro command: import _b "context"
// DO NOT EDIT! Any change will be lost when the file is re-generated

package imports

import (
	. "reflect"
	"context"
	"time"
)

// reflection: allow interpreted code to import "context"
func init() {
	Packages["context"] = Package{
	Binds: map[string]Value{
		"Background":	ValueOf(context.Background),
		"Canceled":	ValueOf(&context.Canceled).Elem(),
		"DeadlineExceeded":	ValueOf(&context.DeadlineExceeded).Elem(),
		"TODO":	ValueOf(context.TODO),
		"WithCancel":	ValueOf(context.WithCancel),
		"WithDeadline":	ValueOf(context.WithDeadline),
		"WithTimeout":	ValueOf(context.WithTimeout),
		"WithValue":	ValueOf(context.WithValue),
	}, Types: map[string]Type{
		"CancelFunc":	TypeOf((*context.CancelFunc)(nil)).Elem(),
		"Context":	TypeOf((*context.Context)(nil)).Elem(),
	}, Proxies: map[string]Type{
		"Context":	TypeOf((*P_context_Context)(nil)).Elem(),
	}, 
	}
}

// --------------- proxy for context.Context ---------------
type P_context_Context struct {
	Object	interface{}
	Deadline_	func(interface{}) (deadline time.Time, ok bool)
	Done_	func(interface{}) <-chan struct{}
	Err_	func(interface{}) error
	Value_	func(_proxy_obj_ interface{}, key interface{}) interface{}
}
func (P *P_context_Context) Deadline() (deadline time.Time, ok bool) {
	return P.Deadline_(P.Object)
}
func (P *P_context_Context) Done() <-chan struct{} {
	return P.Done_(P.Object)
}
func (P *P_context_Context) Err() error {
	return P.Err_(P.Object)
}
func (P *P_context_Context) Value(key interface{}) interface{} {
	return P.Value_(P.Object, key)
}
